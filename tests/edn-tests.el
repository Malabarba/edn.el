(require 'ert)
(require 'edn)

(ert-deftest whitespace ()
  :tags '(edn)
  (should (null (edn-parse "")))
  (should (null (edn-parse " ")))
  (should (null (edn-parse "   ")))
  (should (null (edn-parse "	")))
  (should (null (edn-parse "		")))
  (should (null (edn-parse ",")))
  (should (null (edn-parse ",,,,")))
  (should (null (edn-parse "	  , ,
")))
  (should (null (edn-parse"
  ,, 	")))
  (should (equal [a b c d] (edn-parse "[a ,,,,,, b,,,,,c ,d]"))))

(ert-deftest symbols ()
  :tags '(edn symbol)
  (should (equal 'foo (edn-parse "foo")))
  (should (equal 'foo\. (edn-parse "foo.")))
  (should (equal '%foo\. (edn-parse "%foo.")))
  (should (equal 'foo/bar (edn-parse "foo/bar")))
  (equal 'some\#sort\#of\#symbol (edn-parse "some#sort#of#symbol"))
  (equal 'truefalse (edn-parse "truefalse"))
  (equal 'true. (edn-parse "true."))
  (equal '/ (edn-parse "/"))
  (should (equal '.true (edn-parse ".true")))
  (should (equal 'some:sort:of:symbol (edn-parse "some:sort:of:symbol")))
  (equal 'foo-bar (edn-parse "foo-bar")))

(ert-deftest booleans ()
  :tags '(edn boolean)
  (should (equal t (edn-parse "true")))
  (should (equal nil (edn-parse "false "))))

(ert-deftest characters ()
  :tags '(edn characters)
  (should (equal 97 (edn-parse "\\a")))
  (should (equal 960 (edn-parse "\\u03C0")))
  (should (equal 'newline (edn-parse "\\newline"))))

(ert-deftest elision ()
  :tags '(edn elision)
  (should-not (edn-parse "#_foo"))
  (should-not (edn-parse "#_ 123"))
  (should-not (edn-parse "#_:foo"))
  (should-not (edn-parse "#_ \\a"))
  (should-not (edn-parse "#_
\"foo\""))
  (should-not (edn-parse "#_ (1 2 3)"))
  (should (equal '(1 3) (edn-parse "(1 #_ 2 3)")))
  (should (equal '[1 2 3 4] (edn-parse "[1 2 #_[4 5 6] 3 4]")))
  (should (map-equal (make-seeded-hash-table :foo :bar)
                     (edn-parse "{:foo #_elided :bar}")))
  (should (equal (edn-list-to-set '(1 2 3 4))
                 (edn-parse "#{1 2 #_[1 2 3] 3 #_ (1 2) 4}")))
  (should (equal [a d] (edn-parse "[a #_ ;we are discarding what comes next
 c d]"))))

(ert-deftest string ()
  :tags '(edn string)
  (should (equal "this is a string" (edn-parse "\"this is a string\"")))
  (should (equal "this has an escaped \"quote in it"
                 (edn-parse "\"this has an escaped \\\"quote in it\"")))
  (should (equal "foo\\tbar" (edn-parse "\"foo\\tbar\"")))
  (should (equal "foo\\nbar" (edn-parse "\"foo\\nbar\"")))
  (should (equal "this is a string \\ that has an escaped backslash"
                 (edn-parse "\"this is a string \\\\ that has an escaped backslash\"")))
  (should (equal "[" (edn-parse "\"[\""))))

(ert-deftest keywords ()
  :tags '(edn keywords)
  (should (equal :namespace\.of\.some\.length/keyword-name
                 (edn-parse ":namespace.of.some.length/keyword-name")))
  (should (equal :\#/\# (edn-parse ":#/#")))
  (should (equal :\#/:a (edn-parse ":#/:a")))
  (should (equal :\#foo (edn-parse ":#foo"))))

(ert-deftest integers ()
  :tags '(edn integers)
  (should (= 0 (edn-parse "0")))
  (should (= 0 (edn-parse "+0")))
  (should (= 0 (edn-parse "-0")))
  (should (= 100 (edn-parse "100")))
  (should (= -100 (edn-parse "-100"))))

(ert-deftest floats ()
  :tags '(edn floats)
  (should (= 12.32 (edn-parse "12.32")))
  (should (= -12.32 (edn-parse "-12.32")))
  (should (= 9923.23 (edn-parse "+9923.23")))
  (should (= 4.5e+044 (edn-parse "45e+43")))
  (should (= -4.5e-042 (edn-parse "-45e-43")))
  (should (= 4.5e+044 (edn-parse "45E+43"))))

(ert-deftest lists ()
  :tags '(edn lists)
  (should-not (edn-parse "()"))
  (should (equal '(1 2 3) (edn-parse "( 1 2 3)")))
  (should (equal '(12.1 ?a foo :bar) (edn-parse "(12.1 \\a foo :bar)")))
  (should (equal '((:foo bar :bar 12)) (edn-parse "( (:foo bar :bar 12))"))))

(ert-deftest vectors ()
  :tags '(edn vectors)
  (should (equal [] (edn-parse "[]")))
  (should (equal '[1 2 3] (edn-parse "[ 1 2 3 ]")))
  (should (equal '[12.1 ?a foo :bar] (edn-parse "[ 12.1 \\a foo :bar]")))
  (should (equal '[[:foo bar :bar 12]] (edn-parse "[[:foo bar :bar 12]]")))
  (should (equal '[( :foo bar :bar 12 ) "foo"] (edn-parse "[(:foo bar :bar 12) \"foo\"]"))))

(defun map-equal (m1 m2)
  (and (and (hash-table-p m1) (hash-table-p m2))
       (eq (hash-table-test m1) (hash-table-test m2))
       (= (hash-table-count m1) (hash-table-count m2))
       (equal (hash-table-keys m1) (hash-table-keys m2))
       (equal (hash-table-values m1) (hash-table-values m2))))

(defun make-seeded-hash-table (&rest keys-and-values)
  (let ((m (make-hash-table :test #'equal))
        (kv-pairs (-partition 2 keys-and-values)))
    (dolist (pair kv-pairs)
      (puthash (first pair) (second pair) m))
    m))

(ert-deftest maps ()
  :tags '(edn maps)
  (should (hash-table-p (edn-parse "{}")))
  (should (map-equal (make-seeded-hash-table :foo :bar :baz :qux)
                     (edn-parse "{ :foo :bar :baz :qux}")))
  (should (map-equal (make-seeded-hash-table 1 "123" 'vector [1 2 3])
                     (edn-parse "{ 1 \"123\" vector [1 2 3]}"))))

(ert-deftest sets ()
  :tags '(edn sets)
  (should (edn-set-p (edn-parse "#{}")))
  (should (equal (edn-list-to-set '(1 2 3)) (edn-parse "#{1 2 3}")))
  (should (equal (edn-list-to-set '(1 [1 2 3] 3)) (edn-parse "#{1 [1 2 3] 3}"))))

(ert-deftest comment ()
  :tags '(edn comments)
  (should-not (edn-parse ";nada"))
  (should (equal 1 (edn-parse ";; comment
1")))
  (should (equal [1 2 3] (edn-parse "[1 2 ;comment to eol
3]")))
  (should (equal '[valid more items] (edn-parse "[valid;touching trailing comment
 more items]"))))

(edn-add-handler "my/cool-handler" (lambda (val) 1))
(edn-add-handler :my/other-handler (lambda (val) 2))

(ert-deftest tags ()
  :tags '(edn tags)
  (should-error (edn-parse "#my/handler missing"))
  (should (= 1 (edn-parse "#my/cool-handler missing")))
  (should (= 2 (edn-parse "#my/other-handler {:foo :bar}"))))
